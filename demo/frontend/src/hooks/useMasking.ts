import { useState, useEffect, useRef, useCallback } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { Point, SavedMask } from '../types/app.types'; // Removed AutoGeneratedMaskData
import { predictMaskFromPoints, generateMasksAutomatically } from '../services/api';

export interface UseMaskingReturn {
  points: Point[];
  savedMasks: SavedMask[];
  isLoadingMask: boolean; // Point-based prediction loading
  isLoadingAutoMask: boolean; // Automatic generation loading
  maskingError: string | null; // Error state specific to masking
  canvasRef: React.RefObject<HTMLCanvasElement | null>; // Allow null
  imageRef: React.RefObject<HTMLImageElement | null>; // Allow null - Ref to the actual image element for dimensions
  setPoints: React.Dispatch<React.SetStateAction<Point[]>>; // Allow external clearing if needed
  setSavedMasks: React.Dispatch<React.SetStateAction<SavedMask[]>>; // Allow external clearing
  handleCanvasClick: (event: React.MouseEvent<HTMLCanvasElement>) => void;
  getMaskFromBackend: () => Promise<void>;
  handleGenerateMasksAutomatically: (imageSrc: string | null) => Promise<void>; // Needs imageSrc
  handleToggleMaskActive: (id: string) => void;
  handleRenameMask: (id: string, newName: string) => void;
  handleDeleteMask: (id: string) => void;
  handleResetCurrentPoints: () => void;
  handleClearSavedMasks: () => void;
  handleDownloadActiveMasks: () => void;
  clearMaskingError: () => void;
  // Expose drawCanvas if needed externally, though resize effect handles most cases
  drawCanvas: () => void;
}

export function useMasking(): UseMaskingReturn {
  const [points, setPoints] = useState<Point[]>([]);
  const [savedMasks, setSavedMasks] = useState<SavedMask[]>([]);
  const [isLoadingMask, setIsLoadingMask] = useState<boolean>(false);
  const [isLoadingAutoMask, setIsLoadingAutoMask] = useState<boolean>(false);
  const [maskingError, setMaskingError] = useState<string | null>(null);

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageRef = useRef<HTMLImageElement | null>(null); // Ref to be assigned the loaded image

  const clearMaskingError = useCallback(() => {
    setMaskingError(null);
  }, []);

  // --- Mask Image Loading Effect ---
  useEffect(() => {
    // Load images for newly added masks or masks without loaded images
    savedMasks.forEach((mask) => {
      if (mask.maskB64Png && !mask.loadedImage) {
        const maskImg = new Image();
        maskImg.onload = () => {
          // Update only the specific mask's loadedImage property
          setSavedMasks(currentMasks =>
            currentMasks.map(m =>
              m.id === mask.id ? { ...m, loadedImage: maskImg } : m
            )
          );
        };
        maskImg.onerror = () => {
          console.error(`Failed to load mask image ${mask.id} from Base64.`);
          setMaskingError(prev => (prev ? `${prev}\n` : '') + `Failed to load display for saved mask '${mask.name}'.`);
          // Optionally remove the broken mask or mark it as errored
          // setSavedMasks(currentMasks => currentMasks.filter(m => m.id !== mask.id));
        };
        // Ensure the src is a valid Data URL
        maskImg.src = mask.maskB64Png.startsWith('data:image')
          ? mask.maskB64Png
          : `data:image/png;base64,${mask.maskB64Png}`;
      }
    });
    // Cleanup: Revoke object URLs if mask images are removed? Not applicable here as we use Data URLs.
  }, [savedMasks]); // Rerun when savedMasks array changes identity

  // --- Canvas Drawing Logic ---
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    const mainImg = imageRef.current; // Use the ref to the loaded image

    if (!canvas || !ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!mainImg || mainImg.naturalWidth === 0 || !mainImg.src) {
      // Draw placeholder if no valid image ref or src
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#808080';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Waiting for image...', canvas.width / 2, canvas.height / 2);
      return;
    };

    // Calculate scaling and offset based on the image element's natural dimensions
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const imgWidth = mainImg.naturalWidth;
    const imgHeight = mainImg.naturalHeight;
    const scale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);
    const scaledWidth = imgWidth * scale;
    const scaledHeight = imgHeight * scale;
    const offsetX = (canvasWidth - scaledWidth) / 2;
    const offsetY = (canvasHeight - scaledHeight) / 2;

    // 1. Draw the main image
    ctx.drawImage(mainImg, offsetX, offsetY, scaledWidth, scaledHeight);

    // 2. Draw all *active* saved masks
    ctx.globalAlpha = 0.55; // Semi-transparent masks
    savedMasks.forEach(mask => {
      if (mask.isActive && mask.loadedImage) {
        ctx.drawImage(mask.loadedImage, offsetX, offsetY, scaledWidth, scaledHeight);
      }
    });
    ctx.globalAlpha = 1.0; // Reset global alpha

    // 3. Draw the *current* points being selected
    ctx.fillStyle = 'rgba(0, 255, 255, 0.9)'; // Cyan points
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)'; // Black outline
    ctx.lineWidth = 1.5;
    points.forEach(point => {
      // Convert original image coordinates back to canvas coordinates
      const canvasX = offsetX + point.x * scale;
      const canvasY = offsetY + point.y * scale;
      ctx.beginPath();
      ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI); // Point radius
      ctx.fill();
      ctx.stroke();
    });

  }, [points, savedMasks]); // Dependencies: points and savedMasks trigger redraw

  // --- Canvas Resize Effect ---
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    let animationFrameId: number | null = null;

    const resizeObserver = new ResizeObserver(entries => {
      if (!animationFrameId) {
        animationFrameId = requestAnimationFrame(() => {
          for (const entry of entries) {
            const { width, height } = entry.contentRect;
            const roundedWidth = Math.round(width);
            const roundedHeight = Math.round(height);
            if (canvas.width !== roundedWidth || canvas.height !== roundedHeight) {
              canvas.width = roundedWidth;
              canvas.height = roundedHeight;
              drawCanvas(); // Redraw immediately after resize
            }
          }
          animationFrameId = null;
        });
      }
    });

    const parentElement = canvas.parentElement;
    if (parentElement) {
      resizeObserver.observe(parentElement);
      // Set initial size based on parent
      const { width, height } = parentElement.getBoundingClientRect();
      const roundedWidth = Math.round(width);
      const roundedHeight = Math.round(height);
      if (canvas.width !== roundedWidth || canvas.height !== roundedHeight) {
        canvas.width = roundedWidth;
        canvas.height = roundedHeight;
      }
      // Initial draw needs slight delay to ensure layout/image is ready
      const initialDrawTimeout = setTimeout(drawCanvas, 50);
      return () => {
          clearTimeout(initialDrawTimeout);
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          resizeObserver.unobserve(parentElement);
      };
    }

    // Cleanup if parentElement wasn't found
    return () => {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
    };
  }, [drawCanvas]); // Rerun if drawCanvas identity changes

  // --- Point Selection ---
  const handleCanvasClick = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    const img = imageRef.current;
    const isLoading = isLoadingMask || isLoadingAutoMask; // Combined loading check

    if (isLoading || !canvas || !img || img.naturalWidth === 0) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    // Calculate image scaling and offset *at the time of click*
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const imgWidth = img.naturalWidth;
    const imgHeight = img.naturalHeight;
    const scale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);
    const scaledWidth = imgWidth * scale;
    const scaledHeight = imgHeight * scale;
    const offsetX = (canvasWidth - scaledWidth) / 2;
    const offsetY = (canvasHeight - scaledHeight) / 2;

    // Check if the click is within the bounds of the *displayed* image
    if (clickX >= offsetX && clickX <= offsetX + scaledWidth &&
      clickY >= offsetY && clickY <= offsetY + scaledHeight) {

      // Convert canvas click coordinates back to *original* image coordinates
      const originalX = (clickX - offsetX) / scale;
      const originalY = (clickY - offsetY) / scale;

      setPoints(prevPoints => [...prevPoints, { x: originalX, y: originalY }]);
      clearMaskingError(); // Clear any previous errors
    }
  }, [isLoadingMask, isLoadingAutoMask, clearMaskingError]); // Dependencies

  // --- Mask Prediction (Point-based) ---
  const getMaskFromBackend = useCallback(async () => {
    const img = imageRef.current;
    if (!img || !img.src || points.length === 0) {
      setMaskingError("Please load an image and select at least one point to predict a mask.");
      return;
    }
    setIsLoadingMask(true);
    clearMaskingError();

    try {
      const { maskB64Png, score } = await predictMaskFromPoints(img.src, points); // Use imageRef.current.src

      const newMask: SavedMask = {
        id: uuidv4(),
        name: `Mask ${savedMasks.length + 1}`,
        maskB64Png: maskB64Png, // Store raw base64 (should include data URI)
        points: [...points],
        isActive: true,
        loadedImage: null, // Will be loaded by useEffect
        score: score,
      };
      setSavedMasks(prevMasks => [...prevMasks, newMask]);
      setPoints([]); // Clear points after successful prediction
      console.log(`Saved new mask ${newMask.id}`);
    } catch (err: any) {
      console.error("Error predicting mask:", err);
      setMaskingError(err.message || "An unknown error occurred during mask prediction.");
    } finally {
      setIsLoadingMask(false);
    }
  }, [points, savedMasks.length, clearMaskingError]); // Dependencies

  // --- Automatic Mask Generation ---
  const handleGenerateMasksAutomatically = useCallback(async (imageSrc: string | null) => {
    if (!imageSrc) { // Check if imageSrc is provided
      setMaskingError("No image available for automatic mask generation.");
      return;
    }
    setIsLoadingAutoMask(true);
    clearMaskingError();
    setPoints([]); // Clear any manual points

    try {
      const autoMasksData = await generateMasksAutomatically(imageSrc); // Use provided imageSrc

      if (autoMasksData.length === 0) {
        setMaskingError("Automatic generation did not find any masks."); // Use error state
      } else {
        const newMasks: SavedMask[] = autoMasksData.map((maskData, index) => ({
          id: uuidv4(),
          name: maskData.label || `Auto Mask ${index + 1}`,
          maskB64Png: maskData.mask_b64png, // Assume backend sends with data URI prefix
          points: [],
          isActive: true,
          loadedImage: null, // Will be loaded by useEffect
          score: maskData.score,
        }));
        setSavedMasks(newMasks); // Replace existing masks
        console.log(`Automatically generated and saved ${newMasks.length} masks.`);
      }
    } catch (err: any) {
      console.error("Error generating masks automatically:", err);
      setMaskingError(err.message || "An unknown error occurred during automatic mask generation.");
    } finally {
      setIsLoadingAutoMask(false);
    }
  }, [clearMaskingError]); // Dependencies

  // --- Mask Management Callbacks ---
  const handleToggleMaskActive = useCallback((id: string) => {
    setSavedMasks(prevMasks =>
      prevMasks.map(mask =>
        mask.id === id ? { ...mask, isActive: !mask.isActive } : mask
      )
    );
  }, []);

  const handleRenameMask = useCallback((id: string, newName: string) => {
    setSavedMasks(prevMasks =>
      prevMasks.map(mask =>
        mask.id === id ? { ...mask, name: newName.trim() || `Mask ${prevMasks.findIndex(m => m.id === id) + 1}` } : mask
      )
    );
    console.log(`Renamed mask ${id} to ${newName}`);
  }, []);

  const handleDeleteMask = useCallback((id: string) => {
    setSavedMasks(prevMasks => prevMasks.filter(mask => mask.id !== id));
  }, []);

  const handleResetCurrentPoints = useCallback(() => {
    setPoints([]);
    clearMaskingError();
  }, [clearMaskingError]);

  const handleClearSavedMasks = useCallback(() => {
    setSavedMasks([]);
    setPoints([]); // Also clear points when clearing masks
    clearMaskingError();
  }, [clearMaskingError]);

  const handleDownloadActiveMasks = useCallback(() => {
    const activeMasks = savedMasks.filter(mask => mask.isActive);
    if (activeMasks.length === 0) {
      setMaskingError("No active masks selected to download.");
      return;
    }
    clearMaskingError();

    activeMasks.forEach((mask) => {
      const link = document.createElement('a');
      link.href = mask.maskB64Png.startsWith('data:image')
        ? mask.maskB64Png
        : `data:image/png;base64,${mask.maskB64Png}`;
      const safeName = mask.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || `mask_${mask.id.substring(0, 6)}`;
      link.download = `${safeName}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  }, [savedMasks, clearMaskingError]);

  // Effect to draw canvas whenever dependencies change
   useEffect(() => {
       // Debounce or throttle drawing if performance becomes an issue
       drawCanvas();
   }, [drawCanvas, points, savedMasks]); // Redraw when points or masks change


  return {
    points,
    savedMasks,
    isLoadingMask,
    isLoadingAutoMask,
    maskingError,
    canvasRef,
    imageRef, // Pass the ref out
    setPoints,
    setSavedMasks,
    handleCanvasClick,
    getMaskFromBackend,
    handleGenerateMasksAutomatically,
    handleToggleMaskActive,
    handleRenameMask,
    handleDeleteMask,
    handleResetCurrentPoints,
    handleClearSavedMasks,
    handleDownloadActiveMasks,
    clearMaskingError,
    drawCanvas, // Expose drawCanvas
  };
}