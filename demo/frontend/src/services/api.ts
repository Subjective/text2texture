import axios from 'axios';
import {
  GENERATE_IMAGE_URL,
  PREDICT_MASK_URL,
  GENERATE_MASKS_URL,
  GENERATE_MODEL_URL,
} from '../config/api';
import { Point, SavedMask, AutoGeneratedMaskData } from '../types/app.types';
import { base64ToBlob } from '../utils/blobUtils';

// --- Interfaces for API Responses ---

interface GenerateImageResponse {
  image_b64: string;
  error?: string; // Include potential error field
}

interface PredictMaskResponse {
  status: 'success' | 'error';
  mask_b64png?: string; // Optional on error
  score?: number;
  message?: string; // General message or error details
  error?: string; // Explicit error field
}

interface GenerateMasksResponse {
  status: 'success' | 'error';
  masks?: AutoGeneratedMaskData[]; // Optional on error
  message?: string;
  error?: string;
}

interface GenerateModelResponse {
  fileUrl?: string; // Optional on error
  fileType?: string; // Optional on error
  heightmapFileUrl?: string; // Optional
  error?: string; // Explicit error field
}


// --- API Service Functions ---

/**
 * Generates an image from a text prompt.
 * @param prompt The text prompt.
 * @returns The base64 encoded image data.
 * @throws Throws an error if the API call fails or returns an error.
 */
export const generateImageFromText = async (prompt: string): Promise<string> => {
  try {
    const response = await axios.post<GenerateImageResponse>(GENERATE_IMAGE_URL, {
      prompt: prompt.trim(),
    });

    if (response.data && response.data.image_b64) {
      return response.data.image_b64;
    } else {
      throw new Error(response.data?.error || 'Backend did not return valid image data.');
    }
  } catch (err: any) {
    console.error("API Error - generateImageFromText:", err);
    const errorMsg = err.response?.data?.error || err.message || "Failed to generate image from text.";
    throw new Error(errorMsg);
  }
};

/**
 * Predicts a mask based on an image and selected points.
 * @param imageSrc The base64 encoded source image (Data URL).
 * @param points An array of points selected on the image.
 * @returns An object containing the mask data (base64 png) and score.
 * @throws Throws an error if the API call fails or returns an error status.
 */
export const predictMaskFromPoints = async (imageSrc: string, points: Point[]): Promise<{ maskB64Png: string; score?: number }> => {
  try {
    // Ensure imageSrc is just the Base64 data for the API
    const base64Image = imageSrc.includes(',') ? imageSrc.split(',')[1] : imageSrc;

    const response = await axios.post<PredictMaskResponse>(PREDICT_MASK_URL, {
      image: base64Image,
      points: points,
    });

    if (response.data && response.data.status === 'success' && response.data.mask_b64png) {
      if (typeof response.data.mask_b64png === 'string') {
        return {
          maskB64Png: response.data.mask_b64png, // Return raw base64 (should include data URI from backend)
          score: response.data.score,
        };
      } else {
        throw new Error('Received mask data is not in the expected string format.');
      }
    } else {
      throw new Error(response.data?.error || response.data?.message || 'Mask prediction failed on the backend.');
    }
  } catch (err: any) {
    console.error("API Error - predictMaskFromPoints:", err);
    const errorMsg = err.response?.data?.error || err.response?.data?.message || err.message || "An unknown error occurred during mask prediction.";
    throw new Error(errorMsg);
  }
};

/**
 * Automatically generates masks for a given image.
 * @param imageSrc The base64 encoded source image (Data URL).
 * @returns An array of automatically generated mask data.
 * @throws Throws an error if the API call fails or returns an error status.
 */
export const generateMasksAutomatically = async (imageSrc: string): Promise<AutoGeneratedMaskData[]> => {
  try {
    // Send the full Data URL as the backend might expect it or handle it
    const response = await axios.post<GenerateMasksResponse>(GENERATE_MASKS_URL, {
      image: imageSrc,
    });

    if (response.data && response.data.status === 'success' && Array.isArray(response.data.masks)) {
      return response.data.masks;
    } else {
      // If masks array is missing but status is success, return empty array? Or throw? Let's throw.
      throw new Error(response.data?.error || response.data?.message || 'Automatic mask generation failed or returned invalid data.');
    }
  } catch (err: any) {
    console.error("API Error - generateMasksAutomatically:", err);
    const errorMsg = err.response?.data?.error || err.response?.data?.message || err.message || "An unknown error occurred during automatic mask generation.";
    throw new Error(errorMsg);
  }
};


/**
 * Generates the final 3D model using image, masks, and parameters.
 * @param imageFile The source image File object.
 * @param activeMasks An array of active SavedMask objects.
 * @param params An object containing the 3D model parameters.
 * @returns An object with the URLs and type of the generated files.
 * @throws Throws an error if the API call fails, returns an error, or mask processing fails.
 */
export const generate3DModel = async (
    imageFile: File,
    activeMasks: SavedMask[],
    params: {
        blockWidth: number;
        blockLength: number;
        blockThickness: number;
        depth: number;
        baseHeight: number;
        mode: "protrude" | "carve";
        invert: boolean;
        includeColor: boolean;
    }
): Promise<{ fileUrl: string; fileType: string; heightmapUrl: string | null }> => {

    const formData = new FormData();
    formData.append("color_image", imageFile); // Append the file object

    // Append Active Masks (Handle potential blob conversion errors)
    try {
        activeMasks.forEach((mask, index) => {
            const blob = base64ToBlob(mask.maskB64Png, 'image/png');
            const safeName = mask.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || `mask_${index}`;
            // Use a consistent naming scheme the backend expects, e.g., 'mask_0', 'mask_1'
            formData.append(`mask_${index}`, blob, `${safeName}_${mask.id.substring(0, 6)}.png`);
        });
    } catch (e: any) {
        console.error(`Failed to process mask for upload:`, e);
        throw new Error(`Error processing mask "${(e as any).maskName || 'unknown'}" for upload: ${e.message}. Please try removing it or generating again.`);
        // Note: We might need a way to associate the error with the specific mask name if base64ToBlob fails.
        // For now, throwing a general error.
    }


    // Append mask metadata
    const maskMetadata = activeMasks.map(m => ({ id: m.id, name: m.name }));
    formData.append("mask_metadata", JSON.stringify(maskMetadata));

    // Append Model Parameters
    formData.append("block_width", String(params.blockWidth));
    formData.append("block_length", String(params.blockLength));
    formData.append("block_thickness", String(params.blockThickness));
    formData.append("depth", String(params.depth));
    formData.append("base_height", String(params.baseHeight));
    formData.append("mode", params.mode);
    formData.append("invert", String(params.invert));
    formData.append("include_color", String(params.includeColor));

    try {
        // Post to the final generation endpoint
        const response = await axios.post<GenerateModelResponse>(GENERATE_MODEL_URL, formData, {
            headers: {
                // Content-Type: 'multipart/form-data' is set automatically by axios for FormData
            },
            timeout: 300000, // 5 minute timeout
        });

        if (response.data && response.data.fileUrl && response.data.fileType) {
            return {
                fileUrl: response.data.fileUrl,
                fileType: response.data.fileType,
                heightmapUrl: response.data.heightmapFileUrl || null, // Handle optional heightmap URL
            };
        } else {
            throw new Error(response.data?.error || "Invalid response received from model generation endpoint.");
        }
    } catch (err: any) {
        console.error("API Error - generate3DModel:", err);
        const errorMsg = err.response?.data?.error || err.message || "An unexpected error occurred during 3D model generation.";
        throw new Error(errorMsg);
    }
};