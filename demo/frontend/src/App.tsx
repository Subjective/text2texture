import { useState, useEffect, useRef, useCallback } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';
import { PLYLoader } from 'three/examples/jsm/loaders/PLYLoader.js';
import axios from 'axios'; // Use axios for consistency
import { v4 as uuidv4 } from 'uuid'; // Import uuid for unique IDs

// --- Constants ---
// Define backend URLs
const GENERATE_IMAGE_URL = 'http://127.0.0.1:5000/api/generate_image'; // Endpoint to generate image from text
const PREDICT_MASK_URL = 'http://127.0.0.1:5000/api/predict_mask'; // Endpoint for SAM2-like mask prediction
const GENERATE_MASKS_URL = 'http://127.0.0.1:5000/api/generate_masks'; // NEW: Endpoint for automatic mask generation
const GENERATE_MODEL_URL = 'http://127.0.0.1:5000/api/generate_model'; // Endpoint for final 3D model generation

// --- Types ---
// Basic Point type
type Point = {
  x: number;
  y: number;
};

// Structure for storing saved masks
type SavedMask = {
  id: string; // Unique identifier
  name: string; // User-editable name
  maskB64Png: string; // Base64 PNG string (should include data URI prefix)
  points: Point[]; // Points used to generate this mask (empty for auto-generated)
  isActive: boolean; // Whether the mask should be displayed/used
  loadedImage: HTMLImageElement | null; // Loaded image element for drawing
  score?: number; // Optional score from backend
};

// Type for masks received from the auto-generate endpoint
type AutoGeneratedMaskData = {
  label: string;
  score: number;
  mask_b64png: string; // Backend sends this key
};


// --- Helper Functions ---
// Helper to convert Base64 string to Blob (needed for FormData)
const base64ToBlob = (base64: string, contentType = '', sliceSize = 512): Blob => {
  // Remove Data URI prefix if present
  const base64Data = base64.includes(',') ? base64.split(',')[1] : base64;
  try {
    const byteCharacters = atob(base64Data);
    const byteArrays = [];

    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }

    return new Blob(byteArrays, { type: contentType });
  } catch (e) {
    console.error("Error decoding base64 string:", e, base64.substring(0, 50) + "..."); // Log error and part of string
    // Return an empty blob or re-throw? Returning empty blob might hide issues downstream.
    // Let's re-throw or return null to indicate failure clearly.
    throw new Error("Failed to decode base64 string.");
    // return new Blob([], { type: contentType }); // Alternative: return empty blob
  }
};


// --- ModelViewer Component ---
function ModelViewer({ fileUrl, fileType }: { fileUrl: string | null; fileType: string | null }) {
  const [geometry, setGeometry] = useState<any>(null); // Use 'any' for simplicity with different loader types
  const [loadingError, setLoadingError] = useState<string | null>(null);

  useEffect(() => {
    if (!fileUrl || !fileType) {
      setGeometry(null);
      setLoadingError(null);
      return;
    };

    setGeometry(null); // Reset previous geometry
    setLoadingError(null); // Reset error

    let loader: STLLoader | PLYLoader;
    if (fileType.toLowerCase() === "stl") {
      loader = new STLLoader();
    } else if (fileType.toLowerCase() === "ply") {
      loader = new PLYLoader();
    } else {
      console.error("Unsupported file type for viewer:", fileType);
      setLoadingError(`Cannot display file type: ${fileType}`);
      return;
    }

    console.log(`Loading ${fileType.toUpperCase()} model from: ${fileUrl}`); // Debug log

    loader.load(
      fileUrl,
      (geom) => {
        console.log(`${fileType.toUpperCase()} model loaded successfully.`); // Debug log
        if (fileType.toLowerCase() === "ply") {
          // Ensure geometry is BufferGeometry and compute normals
          if ('computeVertexNormals' in geom) {
            geom.computeVertexNormals(); // Important for lighting on PLY
            console.log("Computed vertex normals for PLY."); // Debug log
          } else {
            console.warn("Loaded PLY geometry does not have computeVertexNormals method.");
          }
        }
        // Center the geometry before setting state
        if ('center' in geom) {
          geom.center();
          console.log("Centered geometry."); // Debug log
        }
        setGeometry(geom);
      },
      (xhr) => { // onProgress callback
        console.log(`Model loading progress: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
      },
      (err) => { // onError callback
        console.error("Error loading model:", err);
        setLoadingError(`Failed to load 3D model preview. Check console for details. Error: ${(err as Error).message || 'Unknown error'}`);
      }
    );

    // Cleanup function (optional, loaders might not need explicit disposal)
    return () => {
      console.log("Cleaning up ModelViewer for:", fileUrl); // Debug log
      // Potential cleanup if needed, e.g., geometry.dispose() if applicable
    };

  }, [fileUrl, fileType]);

  if (loadingError) {
    return (
      <div className="flex items-center justify-center h-full text-lg font-medium text-red-600 bg-red-50 dark:bg-gray-800 dark:text-red-400 p-4 rounded-md">
        Error loading preview: {loadingError}
      </div>
    );
  }

  if (!geometry) {
    return (
      <div className="flex items-center justify-center h-full text-lg font-medium text-gray-600 dark:text-gray-300">
        Loading 3D model preview...
      </div>
    );
  }

  return (
    <Canvas className="w-full h-full" camera={{ position: [150, 150, 150], fov: 50 }}> {/* Adjusted fov */}
      <ambientLight intensity={0.7} /> {/* Slightly increased ambient light */}
      <directionalLight intensity={1.0} position={[50, 100, 150]} castShadow /> {/* Stronger main light */}
      <directionalLight intensity={0.5} position={[-80, -40, -100]} /> {/* Back/fill light */}
      <mesh geometry={geometry} scale={1} castShadow receiveShadow> {/* Ensure scale is appropriate, geometry is centered */}
        {/* Primitive is used when geometry is loaded directly */}
        <primitive object={geometry} attach="geometry" />
        {fileType === "ply" && geometry.attributes.color ? (
          // Use vertexColors if they exist in the PLY
          <meshStandardMaterial vertexColors={true} roughness={0.7} metalness={0.1} />
        ) : (
          // Default material for STL or PLY without color
          <meshStandardMaterial color="#cccccc" roughness={0.6} metalness={0.2} />
        )}
      </mesh>
      {/* Optional: Add a ground plane */}
      {/* <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -geometry?.boundingBox?.min?.y || -50, 0]} receiveShadow>
            <planeGeometry args={[500, 500]} />
            <shadowMaterial opacity={0.3} />
        </mesh> */}
      <OrbitControls />
    </Canvas>
  );
}

// Component for individual mask list items
interface MaskListItemProps {
  mask: SavedMask;
  index: number;
  isLoading: boolean; // Combined loading state
  onToggleActive: (id: string) => void;
  onDelete: (id: string) => void;
  onRename: (id: string, newName: string) => void; // Pass rename handler
}

function MaskListItem({ mask, index, isLoading, onToggleActive, onDelete, onRename }: MaskListItemProps) {
  // Local state to manage the input field value during editing
  const [editingName, setEditingName] = useState<string>(mask.name);

  // Update local state if the mask name prop changes from outside (e.g., initial load)
  useEffect(() => {
    setEditingName(mask.name);
  }, [mask.name]);

  // Handle changes in the input field
  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setEditingName(event.target.value); // Update local state only
  };

  // Handle saving the name when the input loses focus
  const handleNameBlur = () => {
    // Only call the parent rename function if the name actually changed
    if (editingName !== mask.name) {
      // Use default name if editingName is empty, otherwise use editingName
      onRename(mask.id, editingName.trim() || `Mask ${index + 1}`);
    }
    // If the user clears the input and blurs, reset local state to the (potentially new default) prop name
    if (!editingName.trim()) {
      setEditingName(mask.name); // Reset local state to reflect the actual name in parent state
    }
  };

  // Handle saving name on Enter key press
  const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
    if (event.key === 'Enter') {
      handleNameBlur(); // Trigger the same logic as blur
      event.currentTarget.blur(); // Optionally remove focus
    } else if (event.key === 'Escape') {
      setEditingName(mask.name); // Revert changes on Escape
      event.currentTarget.blur();
    }
  };


  return (
    <li className="flex items-center justify-between p-2 rounded-md hover:bg-gray-50 dark:hover:bg-gray-700">
      <input
        type="text"
        value={editingName} // Bind to local state
        onChange={handleNameChange} // Update local state
        onBlur={handleNameBlur} // Update parent state on blur
        onKeyDown={handleKeyDown} // Handle Enter/Escape keys
        className="text-sm text-gray-800 dark:text-gray-200 bg-transparent border-b border-gray-300 dark:border-gray-500 focus:outline-none focus:border-blue-500 mr-2 flex-grow"
        placeholder={`Mask ${index + 1}`}
        disabled={isLoading}
        aria-label={`Mask name for mask ${index + 1}`}
      />
      <span className="text-xs text-gray-500 dark:text-gray-400 mr-2 flex-shrink-0">
        (Score: {mask.score?.toFixed(2) ?? 'N/A'})
      </span>
      <div className="flex items-center space-x-3 flex-shrink-0">
        <label className="flex items-center space-x-1 cursor-pointer" title="Toggle visibility/usage">
          <input
            type="checkbox"
            checked={mask.isActive}
            onChange={() => onToggleActive(mask.id)}
            className="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 disabled:opacity-50"
            disabled={isLoading}
          />
          <span className="text-xs text-gray-700 dark:text-gray-300">Use</span>
        </label>
        <button
          onClick={() => onDelete(mask.id)}
          title="Delete Mask"
          className="text-red-500 hover:text-red-700 disabled:opacity-50"
          disabled={isLoading}
          aria-label={`Delete mask ${index + 1}`}
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
          </svg>
        </button>
      </div>
    </li>
  );
}


// --- Main App Component ---
function App() {
  // --- State Variables ---

  // Input state
  const [inputMethod, setInputMethod] = useState<"upload" | "text">("upload");
  const [imageFile, setImageFile] = useState<File | null>(null); // Holds the File object for upload
  const [textPrompt, setTextPrompt] = useState<string>(""); // Holds the text prompt
  const [imageSrc, setImageSrc] = useState<string | null>(null); // Base64 Data URL of the image for display/masking
  const [uploadedImageFilename, setUploadedImageFilename] = useState<string | null>(null); // Store filename for auto-mask API

  // Masking state
  const [points, setPoints] = useState<Point[]>([]); // Current points for next mask
  const [savedMasks, setSavedMasks] = useState<SavedMask[]>([]); // List of saved masks

  // 3D Model parameters state
  const [blockWidth, setBlockWidth] = useState<number>(100);
  const [blockLength, setBlockLength] = useState<number>(100);
  const [blockThickness, setBlockThickness] = useState<number>(10);
  const [depth, setDepth] = useState<number>(25); // Max height/depth variation
  const [baseHeight, setBaseHeight] = useState<number>(0);
  const [mode, setMode] = useState<"protrude" | "carve">("protrude");
  const [invert, setInvert] = useState<boolean>(false);
  const [includeColor, setIncludeColor] = useState<boolean>(false); // Determines output format (STL vs PLY)

  // Result state
  const [resultUrl, setResultUrl] = useState<string | null>(null);
  const [resultFileType, setResultFileType] = useState<string | null>(null);
  const [heightmapUrl, setHeightmapUrl] = useState<string | null>(null); // NEW: State for heightmap download URL

  // UI Flow and Loading/Error state
  type Step = "input" | "masking" | "params" | "generating" | "result";
  const [currentStep, setCurrentStep] = useState<Step>("input");
  const [isLoadingMask, setIsLoadingMask] = useState<boolean>(false); // Loading for point-based mask prediction
  const [isLoadingAutoMask, setIsLoadingAutoMask] = useState<boolean>(false); // Loading for automatic mask generation
  const [isLoadingModel, setIsLoadingModel] = useState<boolean>(false); // Loading for 3D generation / text-to-image
  const [error, setError] = useState<string | null>(null); // Combined error state

  // Refs
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageRef = useRef<HTMLImageElement | null>(null); // Ref to the loaded image element for dimensions/drawing

  // Combined loading state for disabling UI elements
  const isLoading = isLoadingMask || isLoadingModel || isLoadingAutoMask;

  // --- Image Handling Callbacks ---

  // Clear relevant state when input changes significantly
  const resetForNewImage = () => {
    setImageSrc(null);
    setImageFile(null); // Also clear the stored file object
    setUploadedImageFilename(null); // Clear filename
    setPoints([]);
    setSavedMasks([]);
    setResultUrl(null);
    setResultFileType(null);
    setHeightmapUrl(null); // Clear heightmap URL
    setError(null);
    imageRef.current = null;
    setCurrentStep("input"); // Go back to input step
    // Reset file input visually if needed
    const fileInput = document.getElementById('imageUpload') as HTMLInputElement;
    if (fileInput) fileInput.value = ""; // Attempt to clear file input
  };

  // Handle file selection
  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      // resetForNewImage(); // Reset is good, but maybe too aggressive if user just reselects same file? Let's keep it for now.
      setImageFile(file); // Store the file object FIRST
      setUploadedImageFilename(file.name); // Store the original filename
      setInputMethod("upload"); // Ensure input method is correct

      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target?.result as string;
        const img = new Image();
        img.onload = () => {
          console.log(`Image loaded: ${img.width}x${img.height}`);
          imageRef.current = img;
          setImageSrc(result); // Set Base64 source for canvas AFTER image is loaded
          setCurrentStep("masking"); // Move to masking step
        };
        img.onerror = () => {
          console.error("Failed to load image from file reader result.");
          setError("Failed to load the selected image file. It might be corrupted or an unsupported format.");
          resetForNewImage();
        };
        img.src = result; // Set src AFTER defining onload/onerror
      };
      reader.onerror = () => {
        console.error("Failed to read file.");
        setError("Failed to read the selected file.");
        resetForNewImage();
      };
      reader.readAsDataURL(file); // Read as Data URL for imageSrc
    } else {
      // Handle case where user cancels file selection - only reset if no image was previously loaded
      if (!imageFile && !imageSrc) {
        resetForNewImage();
      }
    }
  };

  // Handle text prompt input change
  const handlePromptChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTextPrompt(e.target.value);
  };

  // Handle generating image from text prompt
  const handleGenerateImageFromText = async () => {
    if (!textPrompt.trim()) {
      setError("Please enter a text prompt.");
      return;
    }
    // resetForNewImage(); // Reset happens implicitly below
    setIsLoadingModel(true); // Use model loading indicator
    setError(null);
    setImageSrc(null); // Clear previous image display immediately
    setImageFile(null);
    setUploadedImageFilename(null); // Clear filename
    setPoints([]);
    setSavedMasks([]);
    setResultUrl(null);
    setResultFileType(null);
    setHeightmapUrl(null); // Clear heightmap URL
    setCurrentStep("generating"); // Indicate generation process

    try {
      const response = await axios.post(GENERATE_IMAGE_URL, {
        prompt: textPrompt.trim(),
      });

      if (response.data && response.data.image_b64) {
        const base64ImageData = response.data.image_b64;
        const fullImageSrc = `data:image/png;base64,${base64ImageData}`; // Assuming PNG
        const generatedFilename = "generated_image.png"; // Define filename

        const img = new Image();
        img.onload = () => {
          console.log(`Generated image loaded: ${img.naturalWidth}x${img.naturalHeight}`);
          imageRef.current = img;
          setImageSrc(fullImageSrc); // Set Base64 source for canvas
          // Convert Base64 back to a File object for final submission consistency
          try {
            const blob = base64ToBlob(base64ImageData, 'image/png');
            const generatedFile = new File([blob], generatedFilename, { type: 'image/png' });
            setImageFile(generatedFile);
            setUploadedImageFilename(generatedFilename); // Store filename for auto-mask API
            setCurrentStep("masking");
          } catch (blobError: any) {
            console.error("Failed to convert generated base64 to Blob:", blobError);
            setError(`Failed to process generated image data: ${blobError.message}`);
            resetForNewImage();
          }
        };
        img.onerror = () => {
          setError("Failed to load the generated image data.");
          resetForNewImage(); // Reset state on error
        };
        img.src = fullImageSrc;

      } else {
        throw new Error(response.data?.error || "Backend did not return valid image data.");
      }
    } catch (err: any) {
      console.error("Error generating image from text:", err);
      setError(err.response?.data?.error || err.message || "Failed to generate image from text.");
      resetForNewImage(); // Reset state on error
    } finally {
      // Loading state is handled by setting the step back to 'masking' or 'input' on success/error
      // setIsLoadingModel(false); // Can remove this if step change handles UI
    }
  };


  // --- Mask Loading Effect ---
  useEffect(() => {
    // This effect should only run to load images for existing masks
    savedMasks.forEach((mask) => {
      if (mask.maskB64Png && !mask.loadedImage) {
        const maskImg = new Image();
        maskImg.onload = () => {
          setSavedMasks(currentMasks =>
            currentMasks.map(m =>
              m.id === mask.id ? { ...m, loadedImage: maskImg } : m
            )
          );
        };
        maskImg.onerror = () => {
          console.error(`Failed to load mask image ${mask.id} from Base64.`);
          setError(prev => (prev ? `${prev}\n` : '') + `Failed to load display for saved mask '${mask.name}'.`);
          // Optionally remove the broken mask or mark it as errored
          // setSavedMasks(currentMasks => currentMasks.filter(m => m.id !== mask.id));
        };
        // Ensure the src is a valid Data URL
        maskImg.src = mask.maskB64Png.startsWith('data:image')
          ? mask.maskB64Png
          : `data:image/png;base64,${mask.maskB64Png}`;
      }
    });
    // Filter out masks that failed to load? Maybe not automatically.
  }, [savedMasks]); // Rerun when savedMasks array changes


  // --- Canvas Drawing Logic ---
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    const mainImg = imageRef.current;

    if (!canvas || !ctx) return;

    // Clear canvas efficiently
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!mainImg || !imageSrc || mainImg.naturalWidth === 0) {
      // Draw placeholder if no valid image
      ctx.fillStyle = '#e0e0e0'; // Slightly darker grey background
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#808080';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('No image loaded or image invalid', canvas.width / 2, canvas.height / 2);
      return;
    };

    // Calculate scaling and offset (using naturalWidth/Height)
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const imgWidth = mainImg.naturalWidth;
    const imgHeight = mainImg.naturalHeight;
    const scale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);
    const scaledWidth = imgWidth * scale;
    const scaledHeight = imgHeight * scale;
    const offsetX = (canvasWidth - scaledWidth) / 2;
    const offsetY = (canvasHeight - scaledHeight) / 2;

    // --- Drawing ---
    // Use requestAnimationFrame for potentially smoother updates, though might be overkill here
    // requestAnimationFrame(() => { // If enabling this, ensure it doesn't cause issues with dependencies

    // 1. Draw the main image
    ctx.drawImage(mainImg, offsetX, offsetY, scaledWidth, scaledHeight);

    // 2. Draw all *active* saved masks
    ctx.globalAlpha = 0.55; // Semi-transparent masks
    savedMasks.forEach(mask => {
      if (mask.isActive && mask.loadedImage) {
        // Draw mask overlay
        ctx.drawImage(mask.loadedImage, offsetX, offsetY, scaledWidth, scaledHeight);
      }
    });
    ctx.globalAlpha = 1.0; // Reset global alpha

    // 3. Draw the *current* points being selected
    ctx.fillStyle = 'rgba(0, 255, 255, 0.9)'; // Cyan points
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)'; // Black outline
    ctx.lineWidth = 1.5;
    points.forEach(point => {
      // Convert original image coordinates back to canvas coordinates
      const canvasX = offsetX + point.x * scale;
      const canvasY = offsetY + point.y * scale;
      ctx.beginPath();
      ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI); // Point radius
      ctx.fill();
      ctx.stroke();
    });

    // }); // End of requestAnimationFrame if used

  }, [points, savedMasks, imageSrc]); // Dependencies: Include imageSrc as it determines if mainImg is valid

  // Effect to redraw canvas when relevant data changes
  useEffect(() => {
    // Only draw if we are in a step where the canvas should be visible AND image is loaded
    if ((currentStep === 'masking' || currentStep === 'params') && imageSrc && canvasRef.current) {
      // Use requestAnimationFrame to schedule the draw before the next browser repaint
      let animationFrameId: number | null = null;
      animationFrameId = requestAnimationFrame(() => {
        drawCanvas();
      });
      // Cleanup function to cancel the frame if the component unmounts or dependencies change before it runs
      return () => {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
      };
    }
    // If step changes away from masking/params, canvas doesn't need redraw
    // Dependencies are correct: redraw when image, points, masks, draw function identity, or step changes.
  }, [imageSrc, points, savedMasks, drawCanvas, currentStep]); // Keep dependencies as they are


  // Effect for handling canvas resizing
  useEffect(() => {
    const canvas = canvasRef.current;
    // Only observe/draw if canvas exists and we are in the masking step
    if (!canvas || currentStep !== 'masking') return;

    let animationFrameId: number | null = null;

    const resizeObserver = new ResizeObserver(entries => {
      if (!animationFrameId) {
        animationFrameId = requestAnimationFrame(() => {
          for (const entry of entries) {
            const { width, height } = entry.contentRect;
            // Use Math.round to avoid fractional pixels causing infinite loops
            const roundedWidth = Math.round(width);
            const roundedHeight = Math.round(height);
            if (canvas.width !== roundedWidth || canvas.height !== roundedHeight) {
              canvas.width = roundedWidth;
              canvas.height = roundedHeight;
              drawCanvas(); // Redraw immediately after resize
            }
          }
          animationFrameId = null;
        });
      }
    });

    const parentElement = canvas.parentElement;
    if (parentElement) {
      resizeObserver.observe(parentElement);
      // Set initial size based on parent
      const { width, height } = parentElement.getBoundingClientRect();
      const roundedWidth = Math.round(width);
      const roundedHeight = Math.round(height);
      if (canvas.width !== roundedWidth || canvas.height !== roundedHeight) {
        canvas.width = roundedWidth;
        canvas.height = roundedHeight;
        // Initial draw needs slight delay to ensure layout is stable
        const initialDrawTimeout = setTimeout(drawCanvas, 50);
        return () => clearTimeout(initialDrawTimeout);
      } else {
        // Still do initial draw even if size matches, in case image just loaded
        const initialDrawTimeout = setTimeout(drawCanvas, 50);
        return () => clearTimeout(initialDrawTimeout);
      }
    }

    // Cleanup
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      if (parentElement) {
        resizeObserver.unobserve(parentElement);
      }
    };
    // Rerun this effect if the step changes *to* masking, or if drawCanvas function identity changes
  }, [currentStep, drawCanvas]);


  // --- Point Selection ---
  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    const img = imageRef.current;

    // Prevent clicking if loading, or no valid canvas/image
    if (isLoading || !canvas || !img || img.naturalWidth === 0) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    // Calculate image scaling and offset *at the time of click*
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const imgWidth = img.naturalWidth;
    const imgHeight = img.naturalHeight;
    const scale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);
    const scaledWidth = imgWidth * scale;
    const scaledHeight = imgHeight * scale;
    const offsetX = (canvasWidth - scaledWidth) / 2;
    const offsetY = (canvasHeight - scaledHeight) / 2;

    // Check if the click is within the bounds of the *displayed* image
    if (clickX >= offsetX && clickX <= offsetX + scaledWidth &&
      clickY >= offsetY && clickY <= offsetY + scaledHeight) {

      // Convert canvas click coordinates back to *original* image coordinates
      const originalX = (clickX - offsetX) / scale;
      const originalY = (clickY - offsetY) / scale;

      // Add the point (using original image coordinates)
      setPoints(prevPoints => [...prevPoints, { x: originalX, y: originalY }]);
      setError(null); // Clear any previous errors
    }
  };

  // --- Mask Prediction (Point-based) ---
  const getMaskFromBackend = async () => {
    if (!imageSrc || points.length === 0) {
      setError("Please select at least one point on the image to predict a mask.");
      return;
    }
    setIsLoadingMask(true);
    setError(null);

    try {
      // Ensure imageSrc is just the Base64 data
      const base64Image = imageSrc.includes(',') ? imageSrc.split(',')[1] : imageSrc;

      const response = await axios.post(PREDICT_MASK_URL, {
        image: base64Image, // Send Base64 image data
        points: points, // Send the current points (in original image coordinates)
      });

      if (response.data && response.data.status === 'success' && response.data.mask_b64png) {
        if (typeof response.data.mask_b64png === 'string') {
          // Create a new mask object
          const newMask: SavedMask = {
            id: uuidv4(),
            name: `Mask ${savedMasks.length + 1}`, // Default name
            maskB64Png: response.data.mask_b64png, // Store raw base64 (should include data URI)
            points: [...points], // Store points used for this mask
            isActive: true, // Active by default
            loadedImage: null, // Will be loaded by useEffect
            score: response.data.score,
          };
          // Add to saved list and clear current points
          setSavedMasks(prevMasks => [...prevMasks, newMask]);
          setPoints([]);
          console.log(`Saved new mask ${newMask.id}`);
        } else {
          throw new Error('Received mask data is not in the expected string format.');
        }
      } else {
        throw new Error(response.data?.message || 'Mask prediction failed on the backend.');
      }
    } catch (err: any) {
      console.error("Error predicting mask:", err);
      setError(err.response?.data?.error || err.message || "An unknown error occurred during mask prediction.");
    } finally {
      setIsLoadingMask(false);
    }
  };

  // --- Automatic Mask Generation ---
  const handleGenerateMasksAutomatically = async () => {
    if (!uploadedImageFilename) {
      setError("No image filename available. Please upload or generate an image first.");
      return;
    }
    setIsLoadingAutoMask(true);
    setError(null);
    setPoints([]); // Clear any manual points

    try {
      const response = await axios.post(GENERATE_MASKS_URL, {
        image: imageSrc, // Send the Base64 image data URL
      });

      if (response.data && response.data.status === 'success' && Array.isArray(response.data.masks)) {
        const autoMasksData: AutoGeneratedMaskData[] = response.data.masks;

        if (autoMasksData.length === 0) {
          setError("Automatic generation did not find any masks."); // Use error state to show message
        } else {
          // Convert received data to SavedMask format
          const newMasks: SavedMask[] = autoMasksData.map((maskData, index) => ({
            id: uuidv4(),
            name: maskData.label || `Auto Mask ${index + 1}`, // Use label from backend or default
            maskB64Png: maskData.mask_b64png, // Assume backend sends with data URI prefix
            points: [], // No points for auto-generated masks
            isActive: true, // Active by default
            loadedImage: null, // Will be loaded by useEffect
            score: maskData.score,
          }));

          // Replace existing masks with the new ones
          setSavedMasks(newMasks);
          console.log(`Automatically generated and saved ${newMasks.length} masks.`);
        }
      } else {
        throw new Error(response.data?.message || 'Automatic mask generation failed on the backend.');
      }
    } catch (err: any) {
      console.error("Error generating masks automatically:", err);
      setError(err.response?.data?.error || err.response?.data?.message || err.message || "An unknown error occurred during automatic mask generation.");
    } finally {
      setIsLoadingAutoMask(false);
    }
  };


  // --- Mask Management Callbacks ---

  // Toggle the active state
  const handleToggleMaskActive = (id: string) => {
    setSavedMasks(prevMasks =>
      prevMasks.map(mask =>
        mask.id === id ? { ...mask, isActive: !mask.isActive } : mask
      )
    );
  };

  // Handle renaming a mask (updates the main state) - *** Called by MaskListItem onBlur/Enter ***
  const handleRenameMask = (id: string, newName: string) => {
    setSavedMasks(prevMasks =>
      prevMasks.map(mask =>
        // Ensure name is not empty, fallback to default if needed
        mask.id === id ? { ...mask, name: newName.trim() || `Mask ${prevMasks.findIndex(m => m.id === id) + 1}` } : mask
      )
    );
    console.log(`Renamed mask ${id} to ${newName}`);
  };

  // Delete a specific mask
  const handleDeleteMask = (id: string) => {
    setSavedMasks(prevMasks => prevMasks.filter(mask => mask.id !== id));
  };

  // Resets only the currently selected points
  const handleResetCurrentPoints = () => {
    setPoints([]);
    setError(null);
  };

  // Clears all saved masks
  const handleClearSavedMasks = () => {
    setSavedMasks([]);
    setPoints([]);
    setError(null);
  };

  // Downloads all *active* masks as individual PNGs
  const handleDownloadActiveMasks = () => {
    const activeMasks = savedMasks.filter(mask => mask.isActive);
    if (activeMasks.length === 0) {
      setError("No active masks selected to download.");
      return;
    }
    setError(null);

    activeMasks.forEach((mask) => {
      const link = document.createElement('a');
      link.href = mask.maskB64Png.startsWith('data:image')
        ? mask.maskB64Png
        : `data:image/png;base64,${mask.maskB64Png}`;
      const safeName = mask.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || `mask_${mask.id.substring(0, 6)}`;
      link.download = `${safeName}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  };


  // --- 3D Model Generation ---
  const handleGenerate3DModel = async () => {
    setError("");
    setIsLoadingModel(true);
    setResultUrl(null);
    setResultFileType(null);
    setCurrentStep("generating");

    if (!imageFile) { // Check imageFile directly
      setError("Source image file is missing. Please re-upload or regenerate.");
      setIsLoadingModel(false);
      setCurrentStep("input");
      return;
    }

    const formData = new FormData();
    formData.append("color_image", imageFile); // Append the file object

    // Append Active Masks
    const activeMasks = savedMasks.filter(m => m.isActive);
    let maskProcessingError = false; // Flag to stop if any mask fails
    activeMasks.forEach((mask, index) => {
      if (maskProcessingError) return; // Skip remaining if one failed
      try {
        const blob = base64ToBlob(mask.maskB64Png, 'image/png');
        const safeName = mask.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || `mask_${index}`;
        // Use a consistent naming scheme the backend expects, e.g., 'mask_0', 'mask_1'
        formData.append(`mask_${index}`, blob, `${safeName}_${mask.id.substring(0, 6)}.png`);
      } catch (e: any) {
        console.error(`Failed to process mask ${mask.id} ("${mask.name}") for upload:`, e);
        setError(`Error processing mask "${mask.name}" for upload: ${e.message}. Please try removing it or generating again.`);
        maskProcessingError = true; // Set flag
      }
    });

    // If any mask failed processing, stop the submission
    if (maskProcessingError) {
      setIsLoadingModel(false);
      setCurrentStep("params"); // Go back to params step
      return;
    }

    // Append mask metadata
    const maskMetadata = activeMasks.map(m => ({ id: m.id, name: m.name }));
    formData.append("mask_metadata", JSON.stringify(maskMetadata));

    // Append Model Parameters
    formData.append("block_width", String(blockWidth));
    formData.append("block_length", String(blockLength));
    formData.append("block_thickness", String(blockThickness));
    formData.append("depth", String(depth));
    formData.append("base_height", String(baseHeight));
    formData.append("mode", mode);
    formData.append("invert", String(invert));
    formData.append("include_color", String(includeColor));

    try {
      // Post to the final generation endpoint
      const response = await axios.post(GENERATE_MODEL_URL, formData, {
        headers: {
          // Content-Type: 'multipart/form-data' is set automatically by axios for FormData
        },
        timeout: 300000, // 5 minute timeout for potentially long generation
      });

      if (response.data && response.data.fileUrl && response.data.fileType) {
        setResultUrl(response.data.fileUrl);
        setResultFileType(response.data.fileType);
        // NEW: Store the heightmap URL from the response
        setHeightmapUrl(response.data.heightmapFileUrl || null); // Handle case where it might be missing
        setCurrentStep("result");
      } else {
        throw new Error(response.data?.error || "Invalid response received from model generation endpoint.");
      }
    } catch (err: any) {
      console.error("Error generating 3D model:", err);
      setError(err.response?.data?.error || err.message || "An unexpected error occurred during 3D model generation.");
      setCurrentStep("params"); // Go back to params step on error
    } finally {
      setIsLoadingModel(false); // Ensure loading state is reset
    }
  };

  // --- Navigation Functions ---
  const goToMasking = () => {
    if (inputMethod === 'text' && !imageSrc && !isLoading) { // Prevent navigation if already generating
      handleGenerateImageFromText(); // Generate image first if needed
    } else if (imageSrc) {
      setCurrentStep("masking");
    } else if (!isLoading) { // Only show error if not loading
      setError("Please upload an image or provide a text prompt first.");
    }
  };

  const goToParams = () => {
    if (!imageSrc) {
      setError("Cannot proceed without an image.");
      setCurrentStep("input");
    } else {
      setCurrentStep("params");
    }
  };


  // --- Render Logic ---
  return (
    // Added overflow-x-hidden to prevent potential horizontal scroll issues
    <div className="max-w-6xl mx-auto p-4 md:p-6 text-gray-900 dark:text-gray-100 font-sans overflow-x-hidden">
      {/* Page Header */}
      <header className="text-center mb-6 md:mb-8">
        <h1 className="text-3xl md:text-4xl font-bold">Text2Texture</h1>
        <p className="text-md md:text-lg text-gray-600 dark:text-gray-400 mt-2">
          Generate 3D models from images or text prompts.
        </p>
      </header>

      {/* Main Content Grid */}
      <main className="grid grid-cols-1 lg:grid-cols-2 gap-6 md:gap-8">

        {/* Left Column: Input, Masking, Parameters */}
        <div className="space-y-6 md:space-y-8">

          {/* === Step 1: Input === */}
          <section id="input-section" className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow-md">
            <h2 className="text-xl md:text-2xl font-semibold mb-4 border-b pb-2 dark:border-gray-600">1. Input Image</h2>

            {/* Input Method Selection */}
            <fieldset className="mb-4">
              <legend className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Choose Input Method:</legend>
              <div className="flex items-center space-x-4">
                <label className="flex items-center space-x-2 cursor-pointer">
                  <input
                    type="radio"
                    name="inputMethod"
                    value="upload"
                    checked={inputMethod === "upload"}
                    onChange={() => { setInputMethod("upload"); resetForNewImage(); }}
                    className="form-radio h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"
                    disabled={isLoading}
                  />
                  <span className="text-sm text-gray-800 dark:text-gray-200">Upload Image</span>
                </label>
                <label className="flex items-center space-x-2 cursor-pointer">
                  <input
                    type="radio"
                    name="inputMethod"
                    value="text"
                    checked={inputMethod === "text"}
                    onChange={() => { setInputMethod("text"); resetForNewImage(); }}
                    className="form-radio h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"
                    disabled={isLoading}
                  />
                  <span className="text-sm text-gray-800 dark:text-gray-200">Generate from Text</span>
                </label>
              </div>
            </fieldset>

            {/* Conditional Input Fields */}
            {inputMethod === "upload" && (
              <div>
                <label htmlFor="imageUpload" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Select Image File:
                </label>
                <input
                  type="file"
                  id="imageUpload"
                  accept="image/png, image/jpeg, image/webp"
                  onChange={handleFileChange}
                  className="block w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 dark:file:bg-gray-700 dark:file:text-gray-300 dark:hover:file:bg-gray-600 disabled:opacity-50"
                  disabled={isLoading}
                />
                <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">PNG, JPG, or WEBP files accepted.</p>
              </div>
            )}

            {inputMethod === "text" && (
              <div>
                <label htmlFor="textPrompt" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Enter Text Prompt:
                </label>
                <textarea
                  id="textPrompt"
                  rows={3}
                  value={textPrompt}
                  onChange={handlePromptChange}
                  placeholder="e.g., A detailed cobblestone path, top-down view"
                  className="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white disabled:opacity-50"
                  disabled={isLoading}
                />
                <button
                  onClick={handleGenerateImageFromText}
                  disabled={isLoading || !textPrompt.trim()}
                  className="mt-2 px-4 py-2 bg-blue-600 text-white text-sm font-semibold rounded-lg shadow hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isLoadingModel ? 'Generating...' : 'Generate Image'}
                </button>
              </div>
            )}
          </section>


          {/* === Step 2: Mask Selection (Conditional) === */}
          {currentStep === 'masking' && imageSrc && (
            <section id="masking-section" className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow-md">
              <h2 className="text-xl md:text-2xl font-semibold mb-4 border-b pb-2 dark:border-gray-600">2. Select Masks (Optional)</h2>
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">Click on the image to place points for manual mask prediction.</p>
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">Alternatively, use 'Generate Masks Automatically' to detect objects.</p>

              {/* Canvas Area for Masking */}
              {/* Added min-h-[200px] or similar to prevent collapse before image loads */}
              <div className="w-full aspect-[4/3] bg-gray-200 dark:bg-gray-700 rounded-lg shadow overflow-hidden relative mb-4 border dark:border-gray-600 min-h-[200px]">
                <canvas
                  ref={canvasRef}
                  onClick={handleCanvasClick}
                  className={`w-full h-full block ${isLoadingMask ? 'cursor-wait' : 'cursor-crosshair'} ${isLoading ? 'opacity-50 pointer-events-none' : ''}`} // Disable clicks when loading
                  style={{ imageRendering: 'pixelated' }} // Optional: for sharper pixels if needed
                />
                {(isLoadingMask || isLoadingAutoMask) && ( // Show overlay for either mask loading state
                  <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10 rounded-lg">
                    <svg className="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    <span className="ml-3 text-white font-medium">
                      {isLoadingAutoMask ? 'Generating masks...' : 'Predicting mask...'}
                    </span>
                  </div>
                )}
              </div>

              {/* Display Current Points */}
              {points.length > 0 && (
                <div className="mb-3 p-2 bg-blue-50 dark:bg-gray-700 border border-blue-200 dark:border-blue-800 rounded text-sm">
                  <p className="text-blue-800 dark:text-blue-200">
                    {points.length} {points.length === 1 ? 'point' : 'points'} selected for next mask.
                  </p>
                </div>
              )}

              {/* Masking Buttons */}
              <div className="flex flex-wrap justify-start gap-2 mb-4">
                {/* Automatic Generation Button */}
                <button
                  onClick={handleGenerateMasksAutomatically}
                  disabled={isLoading || !uploadedImageFilename} // Use combined isLoading
                  className="px-4 py-2 bg-purple-600 text-white text-sm font-semibold rounded-lg shadow hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Automatically detect objects and generate masks (replaces existing masks)"
                >
                  {isLoadingAutoMask ? 'Generating...' : 'Generate Masks Automatically'}
                </button>
                {/* Manual Point-based Prediction Button */}
                <button
                  onClick={getMaskFromBackend}
                  disabled={isLoading || points.length === 0} // Use combined isLoading
                  className="px-4 py-2 bg-blue-600 text-white text-sm font-semibold rounded-lg shadow hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Predict a mask based on the currently selected points"
                >
                  {isLoadingMask ? 'Predicting...' : 'Predict & Save Mask'}
                </button>
                <button
                  onClick={handleResetCurrentPoints}
                  disabled={isLoading || points.length === 0} // Use combined isLoading
                  className="px-4 py-2 bg-yellow-500 text-white text-sm font-semibold rounded-lg shadow hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Clear the currently selected points"
                >
                  Reset Points
                </button>
              </div>

              {/* Saved Masks List */}
              {savedMasks.length > 0 && (
                <div className="mt-4 border-t pt-4 dark:border-gray-600">
                  <h3 className="text-lg font-semibold mb-2 text-gray-700 dark:text-gray-200">
                    Saved Masks ({savedMasks.filter(m => m.isActive).length} active)
                  </h3>
                  <ul className="space-y-1 max-h-48 overflow-y-auto pr-2 border rounded-md p-1 dark:border-gray-600">
                    {savedMasks.map((mask, index) => (
                      <MaskListItem
                        key={mask.id}
                        mask={mask}
                        index={index}
                        isLoading={isLoading} // Pass combined loading state
                        onToggleActive={handleToggleMaskActive}
                        onDelete={handleDeleteMask}
                        onRename={handleRenameMask}
                      />
                    ))}
                  </ul>
                  <div className="flex flex-wrap justify-start gap-2 mt-3">
                    <button
                      onClick={handleClearSavedMasks}
                      disabled={isLoading}
                      className="px-3 py-1 text-xs bg-red-100 text-red-700 rounded-md hover:bg-red-200 dark:bg-red-900 dark:text-red-200 dark:hover:bg-red-800 disabled:opacity-50"
                      title="Remove all saved masks"
                    >
                      Clear All Masks
                    </button>
                    <button
                      onClick={handleDownloadActiveMasks}
                      disabled={isLoading || savedMasks.filter(m => m.isActive).length === 0}
                      className="px-3 py-1 text-xs bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 disabled:opacity-50"
                      title="Download active masks as PNG files"
                    >
                      Download Active Masks
                    </button>
                  </div>
                </div>
              )}

              {/* Navigation Button */}
              <div className="mt-6 text-center">
                <button
                  onClick={goToParams}
                  disabled={isLoading}
                  className="px-6 py-2 bg-green-600 text-white font-semibold rounded-lg shadow hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 disabled:opacity-50"
                >
                  Proceed to 3D Parameters &raquo;
                </button>
              </div>

            </section>
          )}


          {/* === Step 3: 3D Parameters (Conditional) === */}
          {currentStep === 'params' && imageSrc && (
            <section id="params-section" className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow-md">
              <h2 className="text-xl md:text-2xl font-semibold mb-4 border-b pb-2 dark:border-gray-600">3. Configure 3D Model</h2>

              {/* Back Button */}
              <button onClick={() => setCurrentStep('masking')} disabled={isLoading} className="text-sm text-blue-600 hover:underline mb-4 dark:text-blue-400 disabled:opacity-50">&laquo; Back to Mask Selection</button>

              {/* Parameter Form Fields */}
              <div className="space-y-4">
                {/* Two-column grid for numeric inputs */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label htmlFor="blockWidth" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Block Width (mm)</label>
                    <input
                      id="blockWidth" type="number" value={blockWidth} min="1" step="1"
                      onChange={(e) => setBlockWidth(Number(e.target.value))}
                      className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white disabled:opacity-50"
                      disabled={isLoading}
                    />
                  </div>
                  <div>
                    <label htmlFor="blockLength" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Block Length (mm)</label>
                    <input
                      id="blockLength" type="number" value={blockLength} min="1" step="1"
                      onChange={(e) => setBlockLength(Number(e.target.value))}
                      className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white disabled:opacity-50"
                      disabled={isLoading}
                    />
                  </div>
                  <div>
                    <label htmlFor="blockThickness" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Base Thickness (mm)</label>
                    <input
                      id="blockThickness" type="number" value={blockThickness} min="0.1" step="0.1"
                      onChange={(e) => setBlockThickness(Number(e.target.value))}
                      className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white disabled:opacity-50"
                      disabled={isLoading}
                    />
                  </div>
                  <div>
                    <label htmlFor="depth" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Max Feature Depth (mm)</label>
                    <input
                      id="depth" type="number" value={depth} min="0.1" step="0.1"
                      onChange={(e) => setDepth(Number(e.target.value))}
                      className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white disabled:opacity-50"
                      disabled={isLoading}
                      title="Maximum height (protrude) or depth (carve) of features relative to the base"
                    />
                  </div>
                  {/* Base Height - might be less commonly used, keep it simple */}
                  {/* <div>
                    <label htmlFor="baseHeight" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Base Height Offset (mm)</label>
                    <input
                      id="baseHeight" type="number" value={baseHeight} step="0.1"
                      onChange={(e) => setBaseHeight(Number(e.target.value))}
                      className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white disabled:opacity-50"
                      disabled={isLoading}
                      title="Vertical offset for the entire base"
                    />
                  </div> */}
                </div>

                {/* Mode, Invert, Color Options */}
                <div className="flex flex-col sm:flex-row justify-between space-y-2 sm:space-y-0 sm:space-x-4 pt-2">
                  {/* Mode Selection */}
                  <fieldset>
                    <legend className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Mode:</legend>
                    <div className="flex items-center space-x-3">
                      <label className="flex items-center space-x-1 cursor-pointer">
                        <input type="radio" name="mode" value="protrude" checked={mode === "protrude"} onChange={() => setMode("protrude")} className="form-radio h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500" disabled={isLoading} />
                        <span className="text-sm text-gray-800 dark:text-gray-200">Protrude</span>
                      </label>
                      <label className="flex items-center space-x-1 cursor-pointer">
                        <input type="radio" name="mode" value="carve" checked={mode === "carve"} onChange={() => setMode("carve")} className="form-radio h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500" disabled={isLoading} />
                        <span className="text-sm text-gray-800 dark:text-gray-200">Carve</span>
                      </label>
                    </div>
                  </fieldset>

                  {/* Invert Checkbox */}
                  <div className="flex items-center pt-5"> {/* Added pt-5 for alignment */}
                    <input
                      id="invert" type="checkbox" checked={invert} onChange={(e) => setInvert(e.target.checked)}
                      className="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 disabled:opacity-50"
                      disabled={isLoading}
                    />
                    <label htmlFor="invert" className="ml-2 block text-sm text-gray-700 dark:text-gray-300">Invert Heightmap</label>
                  </div>

                  {/* Include Color Checkbox */}
                  <div className="flex items-center pt-5"> {/* Added pt-5 for alignment */}
                    <input
                      id="includeColor" type="checkbox" checked={includeColor} onChange={(e) => setIncludeColor(e.target.checked)}
                      className="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 disabled:opacity-50"
                      disabled={isLoading}
                    />
                    <label htmlFor="includeColor" className="ml-2 block text-sm text-gray-700 dark:text-gray-300">Include Color (PLY)</label>
                  </div>
                </div>
              </div>

              {/* Final Generate Button */}
              <div className="mt-6 pt-4 border-t dark:border-gray-600">
                <button
                  onClick={handleGenerate3DModel}
                  disabled={isLoading} // Use combined isLoading
                  className="w-full py-3 px-4 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-md shadow-sm transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isLoadingModel ? 'Generating Model...' : `Generate ${includeColor ? 'PLY' : 'STL'} Model`}
                </button>
              </div>
            </section>
          )}

          {/* Loading Indicator during Generation Steps */}
          {isLoading && currentStep === 'generating' && ( // Show only during actual generation step
            <div className="flex items-center justify-center p-4 bg-gray-100 dark:bg-gray-700 rounded-lg shadow">
              <svg className="animate-spin h-5 w-5 mr-3 text-blue-600 dark:text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
              </svg>
              <span className="text-gray-700 dark:text-gray-300">
                {isLoadingMask ? "Predicting mask..." :
                  isLoadingAutoMask ? "Generating masks..." :
                    isLoadingModel && inputMethod === 'text' ? "Generating image..." :
                      isLoadingModel ? "Generating 3D model..." : "Processing..."}
                Please wait.
              </span>
            </div>
          )}

          {/* Error Display Area */}
          {error && (
            <div className="mt-4 p-3 bg-red-100 border border-red-400 text-red-700 dark:bg-red-900 dark:border-red-700 dark:text-red-200 rounded-lg shadow">
              <div className="flex justify-between items-start">
                <div>
                  <strong className="font-semibold">Error:</strong>
                  <p className="text-sm whitespace-pre-wrap">{error}</p> {/* Use pre-wrap for newlines */}
                </div>
                <button onClick={() => setError(null)} className="ml-2 text-red-800 dark:text-red-300 hover:text-red-600 dark:hover:text-red-100 flex-shrink-0" aria-label="Dismiss error">
                  &#x2715; {/* Close icon */}
                </button>
              </div>
            </div>
          )}

        </div> {/* End Left Column */}


        {/* Right Column: 3D Viewer / Result */}
        {/* Ensure parent has min-height if needed, or use aspect-ratio */}
        <div className="lg:sticky lg:top-6 h-[60vh] lg:h-[calc(100vh-4rem)] min-h-[400px]"> {/* Added min-height */}
          <section id="viewer-section" className="bg-gray-100 dark:bg-gray-900 p-3 md:p-4 rounded-lg shadow-md h-full flex flex-col">
            <h2 className="text-lg md:text-xl font-semibold mb-3 text-gray-800 dark:text-gray-100 flex-shrink-0">
              {resultUrl ? 'Generated Model Preview' : '3D Preview Area'}
            </h2>

            {/* Loading/Generating State for Viewer */}
            {isLoadingModel && currentStep === 'generating' && (
              <div className="flex-grow flex items-center justify-center bg-gray-200 dark:bg-gray-800 rounded-md">
                <div className="text-center p-4">
                  <svg className="animate-spin h-8 w-8 text-blue-600 dark:text-blue-400 mx-auto mb-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                  </svg>
                  <p className="text-lg font-medium text-gray-700 dark:text-gray-300">Generating 3D Model...</p>
                  <p className="text-sm text-gray-500 dark:text-gray-400">This might take a moment.</p>
                </div>
              </div>
            )}

            {/* Result Display */}
            {currentStep === 'result' && resultUrl && resultFileType && (
              <div className="flex-grow flex flex-col min-h-0"> {/* Ensure flex container takes height */}
                <div className="mb-3 flex-shrink-0 flex flex-wrap gap-2">
                  <a
                    href={resultUrl}
                    download // Suggest download
                    className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 dark:focus:ring-offset-gray-800"
                  >
                    <svg className="-ml-1 mr-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                      <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clipRule="evenodd" />
                      <path fillRule="evenodd" d="M10 3a1 1 0 011 1v6a1 1 0 11-2 0V4a1 1 0 011-1z" clipRule="evenodd" />
                    </svg>
                    Download Model ({resultFileType.toUpperCase()})
                  </a>
                  {/* NEW: Add Heightmap Download Button */}
                  {heightmapUrl && (
                    <a
                      href={heightmapUrl}
                      download // Suggest download
                      className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800"
                    >
                      <svg className="-ml-1 mr-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fillRule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clipRule="evenodd" /> {/* Simple image icon */}
                      </svg>
                      Download Heightmap (PNG)
                    </a>
                  )}
                  <button
                    onClick={resetForNewImage}
                    disabled={isLoading} // Disable if any loading is happening
                    className="inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md shadow-sm text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-gray-800 disabled:opacity-50"
                  >
                    Start Over
                  </button>
                </div>
                {/* Model Viewer Container */}
                {/* Key forces remount on resultUrl change if needed */}
                <div className="flex-grow border border-gray-300 dark:border-gray-600 rounded-lg overflow-hidden bg-gray-200 dark:bg-gray-800 min-h-0">
                  <ModelViewer key={resultUrl} fileUrl={resultUrl} fileType={resultFileType} />
                </div>
              </div>
            )}

            {/* Placeholder when no result and not loading */}
            {!isLoading && currentStep !== 'result' && currentStep !== 'generating' && (
              <div className="flex-grow flex items-center justify-center bg-gray-200 dark:bg-gray-800 rounded-md text-center p-4">
                <p className="text-gray-500 dark:text-gray-400">
                  {currentStep === 'input' ? 'Upload or generate an image to begin.' :
                    currentStep === 'masking' ? 'Select points and predict masks, or proceed to parameters.' :
                      currentStep === 'params' ? 'Configure parameters and click "Generate 3D Model".' :
                        '3D model preview will appear here.'}
                </p>
              </div>
            )}

          </section>
        </div> {/* End Right Column */}

      </main>

      {/* Footer */}
      <footer className="text-center mt-8 md:mt-12 text-gray-500 dark:text-gray-400 text-sm">
        © 2025 Joshua Yin
      </footer>
    </div>
  );
}

export default App;
